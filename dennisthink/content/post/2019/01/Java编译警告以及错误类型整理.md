---
title: "Java编译警告以及错误类型整理"
date: 2019-01-20T21:38:52+08:00
lastmod: 2019-01-28T21:41:52+08:00
# you can close something for this content if you open it in config.toml.
comment: true
mathjax: false
---

# Java编译警告以及错误类型整理

参考:[IBM知识库](https://www.ibm.com/support/knowledgecenter/zh/SS8PJ7_9.5.0/org.eclipse.jdt.doc.user/reference/preferences/java/compiler/ref-preferences-errors-warnings.htm")

## 1. 代码样式


|选项|描述|缺省|
|---|---|---|
|对静态成员的非静态访问|启用此选项后，每次使用表达式接收方访问静态字段或方法时，编译器都会报告错误或警告。应该使用类型名来限定对静态成员的引用。|警告|
|对静态成员的间接访问|当启用了此选项时，每当以间接方式访问静态字段或方法时，编译器将报告错误或警告。应该使用声明类型名来对接口的静态字段进行限定。|忽略|
|对实例字段的未限定访问|启用此选项后，每次遇到未限定的字段访问（例如，遗漏了“this”）时，编译器都会报告错误或警告。|忽略
|对外层类型的不可访问成员的访问|如果此选项处于启用状态，那么每当编译器模拟访问外层类型的不可访问的成员时，编译器将报告错误或警告。这种访问可能会影响性能|忽略
|参数赋值|将值指定给参数通常不是良好的编程习惯。如果此选项处于启用状态，那么编译器对于这种情况将报告错误或警告。|忽略
|未外部化的字符串|当启用了此选项时，对于未外部化的字符串文字（即，未使用 //$NON-NLS- n>$ 进行标记）或对于不属于字符串的未外部化字符串标记，编译器将报告错误或警告。|忽略
|未记录的空块|如果此选项处于启用状态，那么每当编译器遇到不带说明性注释的空块语句时，它将报告错误或警告。|忽略
|未通过 try-with-resource 管理的资源（一致性 1.7 或以上）|如果此选项处于启用状态，那么当局部变量包含类型“java.lang.AutoCloseable”的值，并且已对该资源显式调用方法“close()”，但该资源未由 try-with-resources 块管理时，编译器将发出错误或警告。|忽略|
|具有构造函数名的方法|使用构造函数名来命名方法通常不是良好的编程习惯。如果此选项处于启用状态，那么编译器对于这种情况将报告错误或警告。|警告|
|方法可以为静态方法|如果此选项处于启用状态，那么对于仅引用静态成员的私有方法或终态方法，编译器将报告错误或警告。|忽略
|方法有可能是静态方法|如果此选项处于启用状态，那么对于仅引用静态成员的非私有方法或非终态方法，编译器将报告错误或警告。请注意，可以在子类中覆盖方法，因此，如果您使“可能为静态”的方法成为静态方法，可能会破坏现有客户机。|忽略



## 2. 潜在的编程问题


|选项|描述|缺省|
|---|---|---|
|比较完全相同的值（“x == x”）|如果此选项处于启用状态，那么在比较涉及到完全相同的操作数的情况下（例如，“x == x”），编译器将报告错误或警告。|警告
|赋值没有效果（例如，“x = x”）|如果此选项处于启用状态，那么每当赋值没有任何效果（例如“x = x”）时，编译器将报告错误或警告。|警告
|可能的意外布尔赋值（例如，“if (a = b)”）|如果此选项处于启用状态，那么每当编译器遇到可能的意外布尔赋值（例如“if (a = b)”）时，它将报告错误或警告。|忽略
|装箱和拆箱转换|如果此选项处于启用状态，那么每当编译器遇到装箱或拆箱转换时，它将报告错误或警告。自动装箱可能会对性能造成负面影响。|忽略
|在字符串并置中使用 char 数组|如果此选项处于启用状态，那么每当在字符串并置中使用了 char[] 表达式时，编译器将报告错误或警告。"hello" + new char[]{'w','o','r','l','d'}|警告
|vararg 参数的不精确类型匹配|如果此选项处于启用状态，那么每当编译器遇到 vararg 参数的不精确类型匹配时，它将报告错误或警告。|警告
|空语句|如果此选项处于启用状态，那么每当编译器遇到空语句（例如，包含多余的分号）时，它将报告错误或警告。|忽略
|未使用的对象分配|如果启用了此选项，那么当编译器遇到已分配但是未使用的对象时，它将发出错误或警告，例如： br>if (name == null) /br>   new IllegalArgumentException();|忽略
|不完整的枚举“switch”case|如果此选项处于启用状态，那么每当编译器遇到的“switch”语句不包含所引用枚举的每个枚举常量的“default”case 和 case 语句时，都将发出错误或警告。Java 语言规范 14.11 建议使用此警告。 它有助于确保“switch”语句涵盖所有可能的枚举值。|警告
|即使“default”case 存在也发出信号|启用了此选项时，如果 case 未涵盖枚举常量，那么即使存在“default”case，编译器也将报告错误或发出警告。添加了新的枚举常量时，此选项有助于捕获缺少 case 的语句。|Off
|“switch”缺少“default”case|启用了此选项时，如果“switch”语句缺少“default”case，那么编译器将报告错误或发出警告。 因此，即使所有可能的值都以其他方式由“case”语句涵盖，也将标记缺少的“default”。此选项有助于确保显式处理新的“switch”表达式值，而不忽略这些值。 它还有助于说明“switch”语句之后未初始化的变量的编译错误：合法值集将来会增大，因此，还需要在“default”case 中初始化变量。|忽略
|“switch”case 跳转|如果此选项处于启用状态，那么在一个正在执行的非空 case 中输入 case 时，编译器将报告错误或警告。|忽略
|隐藏的 catch 块|对于 try 语句局部而言，某些 catch 块可能隐藏其他 catch 块，例如：try { throw new java.io.CharConversionException();} catch (java.io.CharConversionException e) {} catch (java.io.IOException e) {}如果此选项处于启用状态，那么对于与已校验的异常相对应的隐藏 catch 块，编译器将报告错误或警告。|警告
|“finally”未正常结束|如果此选项处于启用状态，那么每当“finally”语句未正常结束（例如，包含 return 语句）时，编译器将报告错误或警告。|警告
|死代码（例如，“if (false)”）|如果此选项处于启用状态，那么编译器遇到死代码（例如，“if (false)”）时，它将报告错误或警告。|警告
|资源泄露|如果此选项处于启用状态，那么当局部变量包含类型“java.lang.AutoCloseable”的值（一致性 >= 1.7）或类型“java.io.Closeable”的值（一致性  = 1.6），并且流分析显示未对该值以本地方式调用方法“close()”时，编译器将发出错误或警告。|警告
|潜在的资源泄漏|如果此选项处于启用状态，那么当局部变量包含类型“java.lang.AutoCloseable”的值（一致性 >= 1.7）或类型“java.io.Closeable”的值（一致性  = 1.6），并且流分析显示未通过所有执行路径对该值以本地方式调用方法“close()”时，编译器将发出错误或警告。|忽略
|不带 serialVersionUID 的可序列化类|如果此选项处于启用状态，那么每当实现“java.io.Serializable”的类型不包含 serialVersionUID 字段时，编译器将报告错误或警告。|警告
|继承的方法中缺少同步修饰符|如果此选项处于启用状态，那么编译器遇到的被继承方法缺少同步的修饰符时，它将报告错误或警告。|忽略
|类覆盖“equals()”而不是“hashCode()”|如果此选项处于启用状态，那么编译器遇到的类覆盖“equals()”而不是“hashCode()”时，它将报告错误或警告。|忽略
|建立名称影子和名称冲突,字段声明隐藏了另一个字段或变量|如果此选项处于启用状态，那么在字段声明隐藏了另一个继承的字段时，编译器将报告错误或警告。|忽略
|局部变量声明隐藏了另一个字段或变量|如果此选项处于启用状态，那么在局部变量声明隐藏了另一个字段或变量时，编译器将报告错误或警告。|忽略
|包括构造函数或 Setter 方法参数|如果此选项处于启用状态，那么在构造函数或 Setter 方法参数隐藏了另一个字段或变量时，编译器也将报告错误或警告。|Off
|类型参数隐藏了另一种类型|如果此选项处于启用状态，那么在内部类的类型参数隐藏了外部类型时，编译器将报告错误或警告。|警告
|此方法不会覆盖包的可视方法|包缺省方法在另一个包中不可视，因此不能被覆盖。如果此选项处于启用状态，那么编译器对于这种情况将报告错误或警告。|警告
|接口方法与受保护的“对象”方法相冲突|当启用了此选项时，每当接口定义了与非继承的 Object 方法不兼容的方法时，编译器将报告错误或警告。在解决此冲突之前，将无法实现这样的接口，例如：interface I { int clone(); /br>}|警告


## 3.建议不要使用和限制使用的 API


|选项|描述|缺省|
|---|---|---|
|建议不要使用的 API|如果此选项处于启用状态，那么使用了建议不要使用的 API 时，编译器将报告错误或警告。|警告
|在建议不要使用的代码中使用了建议不要使用的 API 时发出信号|当此选项处于启用状态时，如果在建议不要使用的代码中使用了建议不要使用的 API，那么编译器将发出指示。问题的严重性由“建议不要使用的 API”选项控制。|Off
|在覆盖或实现建议不要使用的方法时发出信号|当启用了此选项时，编译器将在覆盖或实现建议不要使用的方法时发出信号。问题的严重性由“建议不要使用的 API”选项控制。|Off
|被禁止的引用（访问规则）|当启用了此选项时，编译器将指示访问规则中指定的被禁用引用。|错误
|不鼓励引用（访问规则）|当启用了此选项时，编译器将指示访问规则中指定的不鼓励引用。|警告


## 4.不必要的代码

|选项|描述|缺省|
|---|---|---|
|未使用局部变量的值|如果此选项处于启用状态，那么每当声明了局部变量，但从未在该变量的作用域内使用其值时，编译器将报告错误或警告。|警告
|未使用参数的值|如果此选项处于启用状态，那么每当声明了参数，但从未在该参数的作用域内使用其值时，编译器将报告错误或警告。|忽略
|在覆盖和实现方法中忽略|如果此选项处于启用状态，那么每当声明了参数、但是在用于覆盖或实现另一个方法的方法中的作用域内从未使用该参数时，编译器将不会报告错误或警告。|On
|忽略使用“@param”标记记录的参数|如果此选项处于启用状态，那么每当使用“@param”标记记录的未读取参数时，编译器不会报告错误或警告。|On
|未使用的类型参数|如果启用了此选项，那么编译器将对未使用的类型参数发出错误或警告。|忽略
|未使用的导入|如果此选项处于启用状态，那么编译器将对未使用的导入引用报告错误或警告。|警告
|未使用的私有成员|如果此选项处于启用状态，那么每当声明了私有成员但是从未在同一单元中使用它们时，编译器将报告错误或警告。|警告
|不必要的“else”语句|当启用了此选项时，每当编译器遇到不必要的 else 语句（例如 if (condition) return; else doSomething();）时，它将报告错误或警告。|忽略
|不必要的强制类型转换或“instanceof”操作|当启用了此选项时，每当编译器遇到不必要的强制类型转换或“instanceof”操作（例如 if (object instanceof Object) return;）时，它将报告错误或警告。|忽略
|对抛出的异常的不必要声明|如果此选项处于启用状态，那么每当编译器遇到抛出的异常的不必要声明时，它将报告错误或警告。|忽略
|在覆盖和实现方法中忽略|如果此选项处于启用状态，那么每当编译器在用于覆盖或实现另一个方法的方法中遇到所抛出异常的不必要声明时，它将不会报告错误或警告。|On
|忽略带有“@throws”或“@exception”标记的异常|如果此选项处于启用状态，那么每当使用“@throws”或“@exception”标记来记录所抛出异常的不必要声明时，编译器将不会报告错误或警告。|On
|忽略“Exception”和“Throwable”|如果此选项处于启用状态，那么当编译器遇到不必要的“Exception”和“Throwable”异常声明时，它将不会报告错误或警告|On
|未使用的“break”或“continue”标号|如果此选项处于启用状态，那么每当编译器遇到未使用的“中断”或“继续”标签时，它将报告错误或警告。|警告
|多余的超接口|如果此选项处于启用状态，那么每当编译器遇到一种类型显式实现某个接口，而该类型的任何超类型已实现此接口时，编译器将报告错误或警告。|忽略


## 5.通用类型

|选项|描述|缺省|
|---|---|---|
|未校验的通用类型操作|如果此选项处于启用状态，那么每当编译器遇到未校验的通用类型操作时，它将报告错误或警告。|警告
|使用原始类型|如果此选项处于启用状态，那么每当编译器遇到使用原始类型（例如，List 而不是 List String>）的情况时，它将报告错误或警告。|警告
|使用最终类型绑定声明的通用类型参数|如果此选项处于启用状态，那么每当编译器遇到涉及最终类型的类型绑定时，它将报告错误或警告。|警告
|由于原始 API 而忽略不可避免的通用类型问题|启用了此项时，编译器将忽略程序员未能避免的与 Generics 相关的类型问题，因为所引用的 API 已经包含原始类型。 作为一个示例，可以强制某个类型在其方法特征符中使用原始类型和返回类型，这是因为它从超类型覆盖的方法被声明为在第一个位置使用原始类型。最终将旧的 API 泛化之后，这些问题大多数可能会消失，也可能因为您使用的类型参数不正确而产生编译错误。对于方法特征符中的原始引用，将重新出现原始类型问题。|Off



## 6.注释

|选项|描述|缺省|
|---|---|---|
|缺少“@Override”注释|如果此选项处于启用状态，那么每当编译器遇到某一覆盖了另一个已实现方法的方法，并且缺少“@Override”注释时，它将报告错误或警告。|忽略
|包括接口方法的实现（1.6 或更高版本）|如果此选项处于启用状态，那么每当编译器遇到覆盖或实现接口中已声明方法的方法，并且缺少“@Override”注释时，它也将报告错误或警告。请注意，仅当编译器一致性级别为 1.6 或更高时，才允许在这类方法上使用“@Override”，所以此错误或警告从不会出现在 1.5 代码中。|On
|缺少“@Deprecated”注释|如果此选项处于启用状态，那么每当编译器遇到不带附加“@Deprecated”注释的建议不要使用的类型时，它将报告错误或警告。|忽略
|注释被用作超接口|如果此选项处于启用状态，那么每当编译器遇到实现了注释的类型时，它将报告错误或警告。尽管可以这样做，但这不是好的做法。|警告
|“@SuppressWarnings”中未处理的标记|如果此选项处于启用状态，那么只要编译器遇到“@SuppressWarnings”注释中的未知标记时，它就将发出错误或警告。|警告
|启用“@SuppressWarnings”注释|如果此选项处于启用状态，那么编译器将处理“@SuppressWarnings”注释。如果此选项处于禁用状态，那么它将如已除去所有“@SuppressWarnings”注释一样进行操作。|On
|未使用的“@SuppressWarnings”标记|如果此选项处于启用状态，那么每当编译器遇到“@SuppressWarnings”注释中未使用的标记时，它将报告错误或警告。|警告
|阻止带有“@SuppressWarnings”的可选错误|如果此选项处于启用状态，那么“@SuppressWarnings”注释还将阻止可选编译错误，即在此处将选项设置为“错误”。无法阻止必需的编译错误。|Off



## 7.空分析

|选项|描述|缺省|
|---|---|---|
|空指针访问|如果此选项处于启用状态，那么当编译器遇到解除引用肯定为空的局部变量时，它将报告错误或警告。注意，分析无法找到所有空指针访问，请参阅潜在的空指针访问。|警告
|潜在的空指针访问|如果此选项处于启用状态，那么当编译器遇到解除引用可能为空的局部变量时，它将报告错误或警告。请注意，分析非常保守，它只考虑存在疑问的情况。可以通过使用空注释来提高分析的质量，该功能可使用选项启用基于注释的空分析来启用。|忽略
|多余空值检查|如果此选项处于启用状态，那么每当不可为空局部变量的测试结果为空时，编译器将报告错误或警告。|忽略
|在 null 分析中包括“assert”|如果此选项处于启用状态，那么编译器将在执行空分析时采用“assert”语句。|Off
|启用基于注释的空分析|如果此选项处于启用状态，那么编译器会将注释 @Nullable、@NonNull 和 @NonNullByDefault 解释为指定给定类型是否包括值“空”。以下子选项可对这些分析的作用进行进一步控制。另请参阅使用空注释。|Off



## 8 其他

|选项|描述|缺省|
|---|---|---|
|违反空规范|根据此选项，只要检测到以下某种情况，编译器就将发出错误或警告：使用非空注释声明的方法返回了可空表达式可空表达式将作为方法调用中的自变量传递，其中使用非空注释来声明所调用方法的相应参数。可空表达式将分配给使用非空注释声明的局部变量。 br>对于使用非空注释声明的继承方法，覆盖该继承方法的方法将尝试通过指定可空注释（禁止逆变返回）来放宽该约定。 br>对于至少一个参数具有可空声明的继承方法，覆盖该继承方法的方法将尝试通过为其相应参数指定非空注释（禁止协变参数）来收紧该空约定。 br>在上文中，如果表达式确定求值为值 null，或如果已使用可空注释声明了该表达式，那么会将该表达式视为可空。|错误
|空注释与空推断之间存在冲突|根据此选项，只要检测到以下某种情况，编译器就将发出错误或警告：使用非空注释声明的方法返回了确定在某些流中求值为空值的表达式。 br>对于确定在某些流中求值为空值的表达式，该表达式将作为方法调用中的自变量传递，其中使用非空注释来声明所调用方法的相应参数。 br>对于确定在某些流中求值为空值的表达式，该表达式将分配给使用非空注释声明的局部变量。|错误
|从非注释类型到 @NonNull 类型的未经检查的转换|根据此选项，只要检测到以下某种情况，编译器就将发出错误或警告： br>使用非空注释声明的方法返回了表达式，对于该表达式，没有足够的空信息可用于确定证明在运行时没有任何流将传递空值。对于没有足够的空信息可用于确定证明在运行时始终不会求值为空值的表达式，该表达式将作为方法调用中的自变量传递，其中使用非空注释来声明所调用方法的相应参数。 br>对于没有足够的空信息可用于确定证明在运行时始终不会求值为空值的表达式，该表达式将分配给使用非空注释声明的局部变量。 br>未经检查的转换通常是因使用其他未注释的变量或方法所致。|警告
|冗余的空注释|如果此选项处于启用状态，那么尽管在当前位置适用的缺省值已实现相同的效果，但又应用非空注释时，编译器将发出错误或警告。可以使用 @NonNullByDefault 注释来设置这样的缺省值。|警告
|在覆盖方法中未注释“@NonNull”参数|启用了此选项时，如果存在下列所有情况，那么编译器将对覆盖所继承方法的方法的参数报告错误或发出警告： br>被覆盖方法将相应的参数声明为非空。 br>覆盖方法中的参数没有空注释。 br>覆盖方法未受空缺省值影响。 br>已禁用继承空注释。 br>|警告
|缺少对于包的“@NonNullByDefault”注释|如果此选项处于启用状态，那么编译器将在以下情况中发出错误或警告： br>当由于缺少 package-info.java 或 package-info.java 中缺少缺省空注释而导致包中不包含缺省空注释时。 br>当缺省包中的类型不包含缺省空注释时。 br>|忽略
|对空规范使用缺省注释|如果此选项处于启用状态，那么编译器将为空规范使用缺省注释集合。这些注释包含在 Eclipse SDK 中的org.eclipse.jdt.annotation 捆绑软件中。 br>可以指定不同的注释名称以在您的项目中使用，但请注意，Eclipse 编译器仅支持缺省注释中指定的语义： br>org.eclipse.jdt.annotation.Nullable：Java 注释类型的标准名称，当应用于方法特征符、变量声明或者字段声明中的某种类型时，会将解释为 null 在该位置是合法值的规范。 br>当前受支持的位置包括：方法参数、方法返回类型、局部变量和字段。 br>org.eclipse.jdt.annotation.NonNull：Java 注释类型的标准名称，当应用于方法特征符、变量声明或者字段声明中的某种类型时，会将解释为 null 在该位置不是合法值的规范。 br>当前受支持的位置包括：方法参数、方法返回类型、局部变量和字段。 br>org.eclipse.jdt.annotation.NonNullByDefault：Java 注释类型的标准名称。应用于不带注释参数的元素时，会将所注释元素内方法特征符中的所有未注释类型视为已使用非空注释指定了这些类型一样。 br>相反，在将常量“false”作为参数的情况下应用该注释时，将为所注释元素取消外部作用域中的所有相应缺省值。 br>|On
|继承空注释|启用了此选项时，编译器将检查不具备任何显式空注释的每个方法：如果它覆盖具有空注释的方法，那么它会将当前方法视为与被覆盖的方法具有相同的注释。 br>以传递方式应用继承之后以及在被覆盖方法所在位置应用任何缺省空值之后，注释继承将对被覆盖方法使用有效空值。 br>如果（非空缺省值和/或被覆盖方法中）不同的隐式空注释适用于方法特征符中的同一类型，那么这将标记为错误，必须使用显式空注释来消除歧义。|Off
|对字段启用语法空分析|启用了此选项时，编译器将检测某些语法群集，通常将对字段引用产生空的相关警告，但是，如果知道同一字段引用为非空，那么可以阻止产生此警告，风险很小。 使用此选项时，请参阅这些提示。|Off


如果启用了将上述错误视为与致命编译错误相似，那么所有生成的错误（致命错误或可配置错误）都将导致代码不可执行。如果禁用此选项，那么只要代码不包含致命错误（即，语法错误、类型错误或根据 Java 语言规范的任何错误），就可以执行该代码。