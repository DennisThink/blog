---
title: 一个简单的计算器.md
date: 2019-01-20T21:38:52+08:00
lastmod: 2019-01-28T21:41:52+08:00
# you can close something for this content if you open it in config.toml.
comment: true
mathjax: false
---


## 代码位置:    

[](https://github.com/DennisThink/Calculater">https://github.com/DennisThink/Calculater /a>

## 具体介绍:    

最近看完了《Effective Morden C++》,里面主要讲解了  code>C++11/14 ``` 的一些的用法，但是暂时想不到用什么项目来写，就把大学的时候实现的一个计算器又做了一遍，顺便用到了刚刚学到的新知识，算是学以致用吧。这篇文章主要对这个计算器的项目做一个介绍，方便大家理解代码和进行扩展，闲话少说，言归正传。

## ## 1. 整体设计    

#### 1.1 逻辑设计    

计算器的整体设计思路采用的算符优先文法，也就是确定算符的优先级，然后对该算符两侧的运算数进行运算，结果为一个运算数，然后采用递归的方法进行。

 *算符优先表 /*

 table>
 thead>
 tr>
   th>左侧算符 /th>
   th>右侧算符 /th>
   th>优先级 /th>
 /tr>
 /thead>
 tbody>
 tr>
   td>ADD_LEVEL /td>
   td>ADD_LEVEL /td>
   td>LEFT_HIGH /td>
 /tr>
 tr>
   td>ADD_LEVEL /td>
   td>MUL_LEVEL /td>
   td>RIGHT_HIGH /td>
 /tr>
 tr>
   td>ADD_LEVEL /td>
   td>LEFT_BRACKET /td>
   td>RIGHT_HIGH /td>
 /tr>
 tr>
   td>ADD_LEVEL /td>
   td>RIGHT_BRACKET /td>
   td>LEFT_HIGH /td>
 /tr>
 tr>
   td>------- /td>
   td>-------- /td>
   td>------ /td>
 /tr>
 tr>
   td>MUL_LEVEL /td>
   td>ADD_LEVEL /td>
   td>LEFT_HIGH /td>
 /tr>
 tr>
   td>MUL_LEVEL /td>
   td>MUL_LEVEL /td>
   td>LEFT_HIGH /td>
 /tr>
 tr>
   td>MUL_LEVEL /td>
   td>LEFT_BRACKET /td>
   td>RIGHT_HIGH /td>
 /tr>
 tr>
   td>MUL_LEVEL /td>
   td>RIGHT_BRACKET /td>
   td>LEFT_HIGH /td>
 /tr>
 tr>
   td>------- /td>
   td>-------- /td>
   td>------ /td>
 /tr>
 tr>
   td>LEFT_BRACKET /td>
   td>ADD_LEVEL /td>
   td>RIGHT_HIGH /td>
 /tr>
 tr>
   td>LEFT_BRACKET /td>
   td>MUL_LEVEL /td>
   td>RIGHT_HIGH /td>
 /tr>
 tr>
   td>LEFT_BRACKET /td>
   td>LEFT_BRACKET /td>
   td>RIGHT_HIGH /td>
 /tr>
 tr>
   td>LEFT_BRACKET /td>
   td>RIGHT_BRACKET /td>
   td>EQUAL /td>
 /tr>
 tr>
   td>------- /td>
   td>-------- /td>
   td>------ /td>
 /tr>
 tr>
   td>RIGHT_BRACKET /td>
   td>ADD_LEVEL /td>
   td>LEFT_HIGH /td>
 /tr>
 tr>
   td>RIGHT_BRACKET /td>
   td>MUL_LEVEL /td>
   td>LEFT_HIGH /td>
 /tr>
 tr>
   td>RIGHT_BRACKET /td>
   td>LEFT_BRACKET /td>
   td>ERROR /td>
 /tr>
 tr>
   td>RIGHT_BRACKET /td>
   td>RIGHT_BRACKET /td>
   td>LEFT_HIGH /td>
 /tr>
 /tbody>
 /table>

#### 1.2 代码的设计    

代码的整体架构的设计如下:

 img src="https://www.dennisthink.com/wp-content/uploads/2018/04/token_design.png" alt="token" />

#### 1.3 整体流程    

 ol>
 li>解析运算运算式为Tokens。 /li>
 li>是否为 code>( ```  code>Number ```  code>) ```的形式 /li>
 li>是，结束运算，结果为Number。 /li>
 li>不是，从左到右寻找三个连续的运算符，他们的优先级为  code>Left   Medium ``` 和  code>Medium > Right ```,然后对 code>Medium ```运算符左右的运算数进行运算，运算的结果替代  code>LeftNum ```  code>Medium ```  code>RightNum ```的位置。
然后跳转到第2步。 /li>
 /ol>

### 2. 举例说明    

 *举个例子 /*
例如对于  code>2+3*4-5 ```的分析处理过程如下
1. 第一步进行表达式分析，将表达式分析为符号表，分析后的结果如下。

 table>
 thead>
 tr>
   th>原表达式 /th>
   th>符号 /th>
   th>类型 /th>
 /tr>
 /thead>
 tbody>
 tr>
   td>2 /td>
   td>2 /td>
   td>运算数 /td>
 /tr>
 tr>
   td>+ /td>
   td>ADD /td>
   td>加法运算符 /td>
 /tr>
 tr>
   td>3 /td>
   td>3 /td>
   td>运算数 /td>
 /tr>
 tr>
   td>* /td>
   td>MUL /td>
   td>乘法运算符 /td>
 /tr>
 tr>
   td>4 /td>
   td>4 /td>
   td>运算数 /td>
 /tr>
 tr>
   td>- /td>
   td>SUB /td>
   td>减法运算符 /td>
 /tr>
 tr>
   td>5 /td>
   td>5 /td>
   td>运算数 /td>
 /tr>
 /tbody>
 /table>

为了方便运算，将表达式分析结果放在括号里，即最后的分析结果为

 table>
 thead>
 tr>
   th>原表达式 /th>
   th>符号 /th>
   th>类型 /th>
 /tr>
 /thead>
 tbody>
 tr>
   td>( /td>
   td>( /td>
   td>左括号 /td>
 /tr>
 tr>
   td>2 /td>
   td>2 /td>
   td>运算数 /td>
 /tr>
 tr>
   td>+ /td>
   td>ADD /td>
   td>加法运算符 /td>
 /tr>
 tr>
   td>3 /td>
   td>3 /td>
   td>运算数 /td>
 /tr>
 tr>
   td>* /td>
   td>MUL /td>
   td>乘法运算符 /td>
 /tr>
 tr>
   td>4 /td>
   td>4 /td>
   td>运算数 /td>
 /tr>
 tr>
   td>- /td>
   td>SUB /td>
   td>减法运算符 /td>
 /tr>
 tr>
   td>5 /td>
   td>5 /td>
   td>运算数 /td>
 /tr>
 tr>
   td>) /td>
   td>) /td>
   td>右括号运算符 /td>
 /tr>
 /tbody>
 /table>

 ol start="2">
 li>按照  em>1.3 /em>流程，这个表达式的分析过程如下 /li>
 /ol>

```
1.(2+3*4-5) 找到的运算符序列为 + * -，对*的运算结果如下 3*4=12,运算后的表达式为 (2+12-5) 
2.(2+12-5)  找到的运算符序列为 ( + -,对+的运算结果如下 2+12 =14,运算后的表达式为 (14-5)
3.(14-5) 找到的运算符序列为 ( - ),对 - 的运算结果如下 14-5=9，运算后的表达式为 (9)
4.符合条件`2`，运算结束，结果为9。
 ``` /pre>

### 3. 代码展示    

#### 3.1 CToken的代码    

```
namespace calculater {  
class CToken
{
public:
    CToken(){};
    virtual TokenType getTokenType()=0;
    virtual std::string toString()=0;
    virtual ~CToken(){};
};
}
 ``` /pre>

对于CToken来说，主要有两个作用

 ul>
 li>将字符串形式的表达式，表示为解析后的Token列表。 /li>
 li>对数字和运算符提供抽象。 /li>
 /ul>

#### 3.2 CTokenNumber的代码    

```
namespace calculater {  
class TokenNumber:public CToken
{
public:
    explicit TokenNumber(const std::string& str);
    explicit TokenNumber(const double value );
    double   getValue() const;
    virtual  TokenType getTokenType() override final;
    virtual  std::string toString() override final;
private:
    double   m_value;
    std::string m_orgStr;
};
}
 ``` /pre>

对于CTokenNumber来说，主要是用来表示表达式中的数字,用到的C++的知识点。

 ul>
 li> code>namespace ``` ----因为继承自 code>CToken ```，所以将其放在与  code>CToken ```相同的命名空间下。 /li>
 li> code>overrite ```  ----因为 code>CTokenNumber ```,重写了 code>CToken ```的  code>toString() ```方法，使用 code>override ```关键字，可以让编译器进行检查，以防止重写错误。 /li>
 li> code>final ``` ----因为 code>toString() ```没有被重写的需求，所以此处将方法声明为 code>final ```，防止被子类重写。 /li>
 /ul>

#### 3.3 TokenOperator的代码    

```
namespace calculater {  
class TokenOperator:public CToken
{
public:
    explicit TokenOperator();
    virtual ~TokenOperator();
    TokenType getTokenType() override final;
    virtual std::string toString() override;
    virtual OperatorType getOperatorType()=0;
    virtual OperatorPriority getOperatorPriority()=0;
    virtual TokenNumber compute(const TokenNumber& lhs,const TokenNumber& rhs)=0;
};
}
 ``` /pre>

TokenOperator为所有运算符的父类，相对于CToken，这个类多提供三个函数。

 ul>
 li>getOperatorType() ,获取运算符类型，最初的设计是为了做运算符的优先级的比较的。现在只作为运算符的类型标识。 /li>
 li>getOperatorPriority(),获取运算符的优先级级别，用于运算符优先级的比较，确定需要进行计算的运算符。 /li>
 li>TokenNumber compute(const TokenNumber& lhs,const TokenNumber& rhs),对运算数进行计算。 /li>
 li> code>virtual func()=0 ``` ----声明虚函数=0，说明此类不提供虚函数的实现，且不可以进行实例化。 /li>
 /ul>